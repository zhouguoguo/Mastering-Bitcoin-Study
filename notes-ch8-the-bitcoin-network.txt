1.Peer-to-Peer Network Architecture
网络节点在网状网络中互连，具有“平面”拓扑。
除了比特币的P2P协议之外，还有其他的协议像用来挖矿和lightweight或者移动钱包的Stratum.
这些协议由网关路由服务器提供，网关路由服务器使用比特币P2P协议访问比特币网络，然后将网络扩展到运行其他协议的节点。
Stratum服务器将Stratum挖矿节点通过Stratum协议连接至比特币P2P网络:
P2P network --- Stratum Server --- Stratum mining node

2.Node Types and Roles
一个比特币的节点是一些功能的集合:路由，完整区块链数据库，挖矿，钱包服务。
所有的节点都基本具备路由的功能，以参与到网络中。所有的节点参与验证和传播交易与区块，发现与维护与peer的连接。
Full node具备完整的区块链数据，全节点可以自主验证任何交易，不用引用外部的任何内容。
SPV节点或者lightweight节点，只维护一部分的区块内容，验证交易用SPV方法。也就是说SPV节点不具备四个功能之中的完整区块链数据库的功能。
挖矿节点可以是全节点，也可以是轻量级节点。轻量级挖矿节点参与pool mining，并且依赖pool server来维持全节点。
用户钱包可能是全节点的一部分，一般是个桌面比特币客户端。很多用户钱包跑在资源有限的设备上，比如智能手机上，这些是SPV节点。
除了上述在比特币P2P协议中的功能，还有一些服务器和节点运行着其他的协议，比如特殊的矿池协议和轻量级的客户端访问协议。

3.The Extended Bitcoin Network扩展比特币网络(P2P+...)
运行比特币P2P协议的比特币主网，包含大约5000至8000个运行不同比特币客户端版本(bitcoin core)的监听节点还有几百个运行着比特币p2p协议的其他实现版本的节点(比如Bitcoin Classic, Bitcoin Unlimited, BitcoinJ, Libbitcoin, btcd, and bcoin)。
P2P网络中很小一部分的节点是挖矿节点。很多大公司通过运行bitcoin core全节点客户端来与比特币网络交互，它具有区块链数据和网络节点的完整副本，但没有挖矿和钱包功能。这些节点网络边缘路由器，允许很多其他的服务，比如exchanges(交易所), wallets, block explorers, merchant payment processing运行于它之上。
与主要的比特币P2P网络相连的是许多池服务器和协议网关，它们连接运行其他协议的节点。这些其他协议的节点主要是pool mining节点和轻量级钱包节点，他们不具备完整的区块数据。

4.Bitcoin Relay Networks
比特币替代网络，不能替换P2P

5.Network Discovery
当新节点初始化时，通过TCP 8333端口与某已存在节点进行通信获取数据。在建立连接时，该节点要通过传输一些识别信息来进行握手：
nVersion客户端P2P网络版本号
nLocalServices节点支持的本地服务列表，目前只有NODE_NETWORK
nTime当前时间
addrYou从该节点看的对端节点IP地址
addrMe本地节点的IP地址
subver节点上运行的软件类型
bestHeight节点的区块链的区块高度

一个新节点如何找到peer?通过DNS seeds.bitcoin core客户端包含了五个不同的DNS种子的名字。
可以使用-connect=<IPAddress>选项来制定连接的ip，如果指定IP那么不会采取自动发现节点的机制。
如果一条连接上没有流量，节点会周期性发送消息来维持连接。如果一个节点超过90分钟没有在连接里通信，它会被认为已经断开连接。

6.Full Nodes
全节点是指维持包含全部交易信息的完整区块链的节点。如果你需要很大的硬盘空间和两三天的时间来与网络同步，那说明你运行的是全节点，这是去中心化的代价。全节点验证交易不需要引用外部的任何内容。
大约75%的节点运行的是reference client Bitcoin Core，也叫Satoshi client. 也就是上述握手过程中的版本消息中的subver里的"Satoshi"

7.Exchanging "Inventory"交换目录清单
一个全新的节点的同步过程从version message开始，通过version message可以知道一个节点当前的区块高度和软件版本。
更新区块时，对端节点通过Inv message来传输更新区块的哈希值。
配对节点之前可以交换getblocks消息来通知对方本地的最高区块的哈希值。这样当前节点可以通过判断收到的区块哈希不是最新区块的哈希而是之前的老区块的哈希值，来推断自己的区块高度大于对端节点。
本地区块高度大于对端的节点，具有更多的区块数据，可以识别出对端阶段缺少哪些区块信息。它们会通过inv message，来传输所缺少区块的哈希值。然后缺少这些区块信息的节点，可以通过一些列的getdata消息来请求完整的区块信息，然后使用inv里的区块哈希来识别这些区块数据。

8.Simplified Payment Verification (SPV) Nodes
不包含完整的区块信息
随着比特币的普及，SPV节点正成为比特币节点最常见的形式，尤其是比特币钱包。
SPV节点只存储区块头信息，而区块中的交易信息是不下载的。如此这样存下来的信息，较完整的区块信息，小了1000倍.SPV节点没有完整的UTXO的信息，所以SPV验证交易的方法有一些不同，依赖于对端节点提供需要的部分区块信息。
SPV通过引用它在区块链中的深度而非高度，来验证交易。一个SPV节点只验证区块组成的链而不验证所有的交易，并且将区块链连接到感兴趣的交易。
打个比方，当检查第300000区块中的某交易的时候，一个全节点连接所有的300000个区块一直到创世区块，并且建立一个UTXO的完整数据库，通过确认UTXO未被花费，来确定交易的有效性。
而一个SPV节点无法验证UTXO是否被花费，因为SPV节点没有交易信息，因此取而代之，SPV节点会在交易和包含该交易的区块之间建立一条merkle路径。然后SPV节点等到#300001区块到#300006区块链接在区块#300000之上了，再在300001到300006之下建立它的深度来验证交易。六个区块可以保证该交易已经不存在double spend的情况。
如果一个交易事实上不存在于一个区块中，那么一个SPV节点不会认为这个交易存在。一个SPV节点通过验证区块的工作量证明，和交易的merkle路径，来验证交易在区块中是否存在。
当然，一个SPV节点可以验证交易是否存在于区块中，但是不能验证该交易，比如是否存在double spent的情况。该漏洞可以用在拒绝服务攻击(DOS attack)和针对SPV节点的双花攻击中。为防止这种情况发生，SPV节点需要随机地连接到几个节点，以增加它接触诚实节点的可能性。SPV节点随机连接节点的需要，也会受到网络分区攻击或Sybil攻击，它们会让节点连接到假网络或者假节点，而没有机会接触诚实节点。
在大多数的实际应用中，连接正常的SPV节点是足够安全的，并且在资源需求，实用性和安全性中取得了平衡。对于绝对的安全性来说，没有什么可以打败全节点。

SPV节点通过getheaders来获取区块头信息。响应的节点可以通过一个headers消息来发送多达2000个区块头信息。
SPV节点的一个缺陷是在请求特定的交易时，会泄露钱包的隐私信息，如公钥地址。因此，在SPV提出之后，比特币开发者增加一个名叫bloom filter的功能，已解决SPV节点隐私泄露的风险。
Bloom filter，通过使用概率而不是固定的模式，接收交易的子集，而不精确显示他们感兴趣的地址。

9.Bloom Filters
SPV使用概率模式来使用不同的模式pattern来请求交易，使用教具体的pattern那么得到
Bloom Filters实现为可变大小的N二进制和可变数量的M哈希函数。?
哈希函数被设计成为总输出1到N之间的一个结果(对应的二进制数组)
哈希函数是确定的，所以实现了bloom filter的节点会使用相同的哈希函数，对于特定的input总可以得到相同的输出。
通过选择不同长度(N)的bloom filters和一个不同的哈希函数的数目M，bloom filter可以被调优，产生不同等级的精度和隐私性。
Bloom Filters如何工作?
对一个pattern,对pattern做哈希得到1-N之间的数，然后在长度为N的二进制数组中将第该位置1，M个哈希函数，算出M个结果，会相应有M个二进制位从0变为1.
因此，当加入第二个pattern时，继续重复上述步骤，因而可能会有重复的数被算出来，也就是置过1的位被再次置1而没有带来变化。所以越多的pattern带来越低的准确度。
N和M越大，可以以更高的准确度记录更多的pattern
测试一个pattern是否记录在Bloom Filter中的时候，对该pattern做M次哈希，求出对应的位置是否为1，都为1那么大概率该pattern已经被记录过.而如果一个pattern的哈希结果对应的位置有0，说明该pattern肯定没有被记录过。

10.How SPV Nodes Use Bloom Filters
从对端收到的bloom filter用来过滤交易和包含交易的区块，来选择出SPV节点感兴趣的交易，而不泄露该节点感兴趣的地址或者密钥。
一个SPV节点初始化一个空的bloom filter, 然后它从钱包控制的UTXO中提取出感兴趣的公钥哈希值，脚本哈希值和交易id.然后在bloom filter中开始记录这些pattern.然后这个bloom filter就代表了这些pattern
bloom filter记录好之后，SPV节点会发送filterload消息给对端，对端会针对每个进来的交易来检查bloom filter，全节点根据bloom filter对于交易的某些部分进行匹配：
交易id
交易output中的数据
交易input
witness数据
在bloom filter建立起来之后，对端会对每个交易的output针对bloom filter进行检查. 只有匹配的交易会被发送给SPV节点。
对于响应SPV节点的getdata消息，对端节点会发送merkleblock消息，其中包含符合过滤器的区块的header和其中相匹配的交易的merkle路径。对端也会发送ex消息包含所有的匹配的交易数据。
SPV节点会丢弃误报，并把正确匹配的交易拿来更新UTXO集合和钱包余额。当SPV节点更新了自己的UTXO，它也会继续更新自己的bloom filter，以接收更多的匹配的交易。然后全节点使用SPV发来的新bloom filter来匹配新的交易。
一个SPV节点可以通过filteradd消息来添加新pattern，也可以通过filterclear来清空pattern，因为当去掉一个pattern时，不能直接去掉，只能通过清空filter来重新生成。
BIP-37 (Peer Services)定义了SPV节点的bloom filter协议。

11.SPV Nodes and Privacy
Bloom filter隐藏了钱包关心的地址，密钥信息，但是即使使用bloom filter，监听SPV节点流量或通过P2P网络直接连接到SPV节点也能收集足够的信息来了解钱包中的地址。

12.Encrypted and Authenticated Connections
最初的比特币通信实现是采用明文方式，这个不会威胁到全节点，但是对于SPV节点是个很大的问题。
为了解决这个问题，提出了两个加密通信的方式：1.Tor Transport 2.P2P Authentication and Encription with BIP-150/151.

13.Transaction Pools
交易池维护了未确认的交易，一个钱包节点的交易池维护了待确认的收入交易。当交易被接收和验证，它们会被加入到交易池中，并且广播到其他节点。
有些节点还维护了孤立的交易池。如果一个交易的input涉及的父交易没有找到，那么这个交易会被放在孤立的交易池中。
当新的交易到来时，先检查有没有它的子交易在孤儿池里，如果有，该子交易被验证然后从孤儿交易池中转移到交易池中。父母交易的到来触发了一系列相互依赖的交易的串联重建。